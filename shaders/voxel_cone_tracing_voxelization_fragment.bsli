//
// Copyright (C) YuqiaoZhang(HanetakaChou)
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

#ifndef _VOXEL_CONE_TRACING_VOXELIZATION_FRAGMENT_BSLI_
#define _VOXEL_CONE_TRACING_VOXELIZATION_FRAGMENT_BSLI_ 1

#define VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_PHYSICALLY_BASED_RENDERING 1
#define VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_TOON_SHADING 2

#ifndef VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE
#error "physically based rendering or toon shading"
#endif

#include "surface_resource_binding.bsli"
#include "../../Spherical-Harmonic/include/brx_spherical_harmonic.h"
#define BRX_VCT_ENABLE_ILLUMINATION 1
#include "../../Voxel-Cone-Tracing/shaders/brx_voxel_cone_tracing_voxelization_fragment.bsli"
#include "../../Brioche-Shader-Language/shaders/brx_shader_language.bsli"
#include "../../Brioche-Shader-Language/shaders/brx_brdf.bsli"
#include "../../Hemispherical-Directional-Reflectance/shaders/brx_hemispherical_directional_reflectance.bsli"
#include "../../Linearly-Transformed-Cosine/shaders/brx_linearly_transformed_cosine_attenuation.bsli"
#include "../../Linearly-Transformed-Cosine/shaders/brx_linearly_transformed_cosine_radiance.bsli"
#include "../../Spherical-Harmonic/shaders/brx_spherical_harmonic_diffuse_radiance.bsli"
#include "../../Spherical-Harmonic/shaders/brx_spherical_harmonic_specular_radiance.bsli"
#include "toon_shading.bsli"

brx_int2 brx_hdr_application_bridge_get_specular_fresnel_factor_lut_dimension()
{
    return brx_texture_2d_get_dimension(t_lut_specular_hdr_fresnel_factor, 0);
}

brx_float2 brx_hdr_application_bridge_get_specular_fresnel_factor_lut(in brx_float2 in_lut_uv)
{
    return brx_sample_level_2d(t_lut_specular_hdr_fresnel_factor, s_clamp_sampler, in_lut_uv, 0.0).xy;
}

brx_int2 brx_ltc_application_bridge_get_specular_matrix_lut_dimension()
{
    return brx_texture_2d_get_dimension(t_lut_specular_ltc_matrix, 0);
}

brx_float4 brx_ltc_application_bridge_get_specular_matrix_lut(in brx_float2 in_lut_uv)
{
    return brx_sample_level_2d(t_lut_specular_ltc_matrix, s_clamp_sampler, in_lut_uv, 0.0);
}

brx_int3 brx_sh_application_bridge_get_specular_transfer_function_sh_coefficient_lut_dimension()
{
    return brx_texture_2d_array_get_dimension(t_lut_specular_transfer_function_sh_coefficient, 0);
}

brx_float brx_sh_application_bridge_get_specular_transfer_function_sh_coefficient_lut(in brx_float2 in_lut_uv, brx_int in_sh_coefficient_index)
{
    return brx_sample_level_2d_array(t_lut_specular_transfer_function_sh_coefficient, s_clamp_sampler, brx_float3(in_lut_uv, brx_float(in_sh_coefficient_index)), 0.0).x;
}

brx_bool brx_vct_application_bridge_get_surface(in brx_float3 in_normal, in brx_float4 in_tangent, in brx_float2 in_texcoord, out brx_float3 out_surface_shading_normal_world_space, out brx_float3 out_surface_diffuse_color, out brx_float3 out_surface_specular_color, out brx_float out_surface_roughness, out brx_float out_surface_opacity, out brx_float3 out_surface_emissive, out brx_bool out_surface_material_face)
{
    brx_uint buffer_texture_flags;
    brx_float normal_scale;
    brx_float4 base_color_factor;
    brx_float roughness_factor;
    brx_float metallic_factor;
    brx_float3 emissive_factor;
    {
        brx_uint4 auxiliary_packed_vectors[3];
        auxiliary_packed_vectors[0] = brx_byte_address_buffer_load4(t_surface_buffers[FORWARD_SHADING_SURFACE_AUXILIARY_BUFFER_INDEX], 0);
        auxiliary_packed_vectors[1] = brx_byte_address_buffer_load4(t_surface_buffers[FORWARD_SHADING_SURFACE_AUXILIARY_BUFFER_INDEX], 4 * 4);
        auxiliary_packed_vectors[2].xyz = brx_byte_address_buffer_load3(t_surface_buffers[FORWARD_SHADING_SURFACE_AUXILIARY_BUFFER_INDEX], 4 * 4 + 4 * 4);
        buffer_texture_flags = auxiliary_packed_vectors[0].x;
        emissive_factor = brx_uint_as_float(auxiliary_packed_vectors[0].yzw);
        base_color_factor = brx_uint_as_float(auxiliary_packed_vectors[1].xyzw);
        normal_scale = brx_uint_as_float(auxiliary_packed_vectors[2].x);
        metallic_factor = brx_uint_as_float(auxiliary_packed_vectors[2].y);
        roughness_factor = brx_uint_as_float(auxiliary_packed_vectors[2].z);
    }

    brx_float2 texcoord = in_texcoord;

    brx_float3 geometry_normal_world_space = brx_normalize(in_normal);

    brx_branch if (0u != (buffer_texture_flags & SURFACE_TEXTURE_FLAG_NORMAL))
    {
        brx_float3 tangent_world_space = brx_normalize(in_tangent.xyz);

        brx_float3 bitangent_world_space = brx_cross(geometry_normal_world_space, tangent_world_space) * ((in_tangent.w >= 0.0) ? 1.0 : -1.0);

        // ["5.20.3. material.normalTextureInfo.scale" of "glTF 2.0 Specification"](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#_material_normaltextureinfo_scale)
        brx_float3 shading_normal_tangent_space = brx_normalize((brx_sample_2d(t_surface_images[FORWARD_SHADING_SURFACE_NORMAL_TEXTURE_INDEX], s_wrap_sampler, texcoord).xyz * 2.0 - brx_float3(1.0, 1.0, 1.0)) * brx_float3(normal_scale, normal_scale, 1.0));

        out_surface_shading_normal_world_space = brx_normalize(tangent_world_space * shading_normal_tangent_space.x + bitangent_world_space * shading_normal_tangent_space.y + geometry_normal_world_space * shading_normal_tangent_space.z);
    }
    else
    {
        out_surface_shading_normal_world_space = geometry_normal_world_space;
    }

    brx_float4 base_color_and_opacity;
    brx_branch if (0u != (buffer_texture_flags & SURFACE_TEXTURE_FLAG_BASE_COLOR))
    {
        base_color_and_opacity = base_color_factor * brx_sample_2d(t_surface_images[FORWARD_SHADING_SURFACE_BASE_COLOR_TEXTURE_INDEX], s_wrap_sampler, texcoord);
    }
    else
    {
        base_color_and_opacity = base_color_factor;
    }

    brx_float3 surface_base_color = base_color_and_opacity.xyz;

    // usually the vertices within the same model is organized from back to front
    // we can simply use the over operation to render the result correctly (just like how we render the imgui)
    out_surface_opacity = base_color_and_opacity.w;

#if defined(VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE) && (VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_PHYSICALLY_BASED_RENDERING == VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE)
    brx_float surface_metallic;
    brx_branch if (0u != (buffer_texture_flags & SURFACE_TEXTURE_FLAG_METALLIC_ROUGHNESS))
    {
        brx_float2 roughness_metallic = brx_sample_2d(t_surface_images[FORWARD_SHADING_SURFACE_METALLIC_ROUGHNESS_TEXTURE_INDEX], s_wrap_sampler, texcoord).yz;
        out_surface_roughness = roughness_factor * roughness_metallic.x;
        surface_metallic = metallic_factor * roughness_metallic.y;
    }
    else
    {
        out_surface_roughness = roughness_factor;
        surface_metallic = metallic_factor;
    }

    {
        const brx_float dielectric_specular = 0.04;
        // UE4: https://github.com/EpicGames/UnrealEngine/blob/4.21/Engine/Shaders/Private/MobileBasePassPixelShader.usf#L376
        out_surface_specular_color = brx_clamp((dielectric_specular - dielectric_specular * surface_metallic) + surface_base_color * surface_metallic, 0.0, 1.0);
        out_surface_diffuse_color = brx_clamp(surface_base_color - surface_base_color * surface_metallic, 0.0, 1.0);
    }
#elif defined(VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE) && (VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_TOON_SHADING == VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE)
    {
        out_surface_roughness = 1.0;
    }

    {
        out_surface_specular_color = brx_float3(0.0, 0.0, 0.0);
        out_surface_diffuse_color = surface_base_color;
    }
#else
#error Unknown Render Style
#endif
    

    brx_branch if (0u != (buffer_texture_flags & SURFACE_TEXTURE_FLAG_EMISSIVE))
    {
        out_surface_emissive = emissive_factor * brx_sample_2d(t_surface_images[FORWARD_SHADING_SURFACE_EMISSIVE_TEXTURE_INDEX], s_wrap_sampler, texcoord).xyz;
    }
    else
    {
        out_surface_emissive = emissive_factor;
    }

    // Specular Anti-Aliasing
    // "7.8.1 Mipmapping BRDF and Normal Maps" of "Real-Time Rendering Third Edition"
    // "9.13.1 Filtering Normals and Normal Distributions" of "Real-Time Rendering Fourth Edition"
    // UE4: [NormalCurvatureToRoughness](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/BasePassPixelShader.usf#L67)
    // U3D: [TextureNormalVariance ](https://github.com/Unity-Technologies/Graphics/blob/v10.8.1/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl#L214)
    {
        const brx_float cvar_normal_curvature_to_roughness_scale = 1.0;
        const brx_float cvar_normal_curvature_to_roughness_bias = 0.0;
        const brx_float cvar_normal_curvature_to_roughness_exponent = 0.3333333;

        brx_float3 dn_dx = brx_ddx(geometry_normal_world_space);
        brx_float3 dn_dy = brx_ddy(geometry_normal_world_space);
        brx_float x = brx_dot(dn_dx, dn_dx);
        brx_float y = brx_dot(dn_dy, dn_dy);

        brx_float curvature_approx = brx_pow(brx_max(x, y), cvar_normal_curvature_to_roughness_exponent);
        brx_float geometric_aa_roughness = brx_clamp(curvature_approx * cvar_normal_curvature_to_roughness_scale + cvar_normal_curvature_to_roughness_bias, 0.0, 1.0);

        out_surface_roughness = brx_max(out_surface_roughness, geometric_aa_roughness);
    }

    // Prevent the roughness to be zero
    // https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/CapsuleLightIntegrate.ush#L94
    {
        const brx_float cvar_global_min_roughness_override = 0.02;
        out_surface_roughness = brx_max(out_surface_roughness, cvar_global_min_roughness_override);
    }

    out_surface_material_face = (0u != (buffer_texture_flags & SURFACE_MATERIAL_FLAG_FACE));

    return true;
}

void brx_vct_application_bridge_get_outgoing_radiances(in brx_float3 in_outgoing_directions_world_space[(brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT))], in brx_float3 in_surface_position_world_space, in brx_float3 in_surface_shading_normal_world_space, in brx_float3 in_surface_emissive, in brx_float3 in_surface_diffuse_color, in brx_float3 in_surface_specular_color, in brx_float in_surface_roughness, in brx_bool in_surface_material_face, in brx_float3 in_surface_position_non_deformed_model_space, out brx_float3 out_outgoing_radiances[(brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT))])
{
    const brx_float INTERNAL_IRRADIANCE_THRESHOLD = 1e-4;
    const brx_float INTERNAL_ATTENUATION_THRESHOLD = 1e-4;
    const brx_float INTERNAL_HALF_VECTOR_LENGTH_SQUARE_MINIMUM = 1e-8;

    // Emissive
    {
        brx_unroll for (brx_int direction_index = 0; direction_index < (brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT)); ++direction_index)
        {
            out_outgoing_radiances[direction_index] = in_surface_emissive;
        }
    }

    // Albedo
    brx_float3 surface_diffuse_albedo;
    brx_float3 surface_specular_albedos[(brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT))];
    brx_branch if ((g_area_lighting_count > 0) || ((ENVIRONMENT_MAP_LAYOUT_EQUIRECTANGULAR == g_environment_map_layout) || (ENVIRONMENT_MAP_LAYOUT_OCTAHEDRAL == g_environment_map_layout)))
    {
        surface_diffuse_albedo = in_surface_diffuse_color;

        brx_unroll for (brx_int direction_index = 0; direction_index < (brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT)); ++direction_index)
        {
            brx_float3 outgoing_direction_world_space = in_outgoing_directions_world_space[direction_index];

            brx_branch if (brx_dot(in_surface_shading_normal_world_space, outgoing_direction_world_space) > 0.0)
            {
                surface_specular_albedos[direction_index] = brx_hdr_specular_albedo(in_surface_specular_color, in_surface_roughness, in_surface_shading_normal_world_space, outgoing_direction_world_space);
            }
            else
            {
                surface_specular_albedos[direction_index] = brx_float3(0.0, 0.0, 0.0);
            }
        }
    }
    else
    {
        surface_diffuse_albedo = brx_float3(0.0, 0.0, 0.0);

        brx_unroll for (brx_int direction_index = 0; direction_index < (brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT)); ++direction_index)
        {
            surface_specular_albedos[direction_index] = brx_float3(0.0, 0.0, 0.0);
        }
    }

    // Area Lighting
    brx_loop for (brx_int area_lighting_index = 0; area_lighting_index < g_area_lighting_count; ++area_lighting_index)
    {
        brx_float4 area_lighting_auxiliary_packed_vectors[3] = brx_array_constructor_begin(brx_float4, 3)
            g_area_lightings[3 * area_lighting_index + 0] brx_array_constructor_split
            g_area_lightings[3 * area_lighting_index + 1] brx_array_constructor_split
            g_area_lightings[3 * area_lighting_index + 2] brx_array_constructor_end;

        brx_float3 area_lighting_position = area_lighting_auxiliary_packed_vectors[0].xyz;
        brx_float3 area_lighting_edge1 = area_lighting_auxiliary_packed_vectors[1].xyz;
        brx_float3 area_lighting_edge2 = area_lighting_auxiliary_packed_vectors[2].xyz;

        // https://github.com/AcademySoftwareFoundation/Imath/blob/main/src/Imath/half.h
        // HALF_MAX 65504.0
        brx_float3 area_lighting_radiance = brx_clamp(brx_float3(area_lighting_auxiliary_packed_vectors[0].w, area_lighting_auxiliary_packed_vectors[1].w, area_lighting_auxiliary_packed_vectors[2].w), brx_float3(0.0, 0.0, 0.0), brx_float3(65504.0, 65504.0, 65504.0));

        brx_float3 quad_vertices_world_space[4] = brx_array_constructor_begin(brx_float3, 4)
            area_lighting_position brx_array_constructor_split
            (area_lighting_position + area_lighting_edge1) brx_array_constructor_split
            (area_lighting_position + area_lighting_edge1 + area_lighting_edge2) brx_array_constructor_split
            (area_lighting_position + area_lighting_edge2) brx_array_constructor_end;

        brx_float quad_culling_range;
        {
            brx_float quad_area = brx_length(brx_cross(quad_vertices_world_space[1] - quad_vertices_world_space[0], quad_vertices_world_space[3] - quad_vertices_world_space[0]));
            brx_float maximum_area_lighting_radiance = brx_max(brx_max(area_lighting_radiance.x, area_lighting_radiance.y), area_lighting_radiance.z);

            quad_culling_range = brx_sqrt((maximum_area_lighting_radiance * quad_area) / INTERNAL_IRRADIANCE_THRESHOLD);
        }

#if defined(VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE) && (VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_PHYSICALLY_BASED_RENDERING == VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE)
        brx_float area_lighting_attenuation = brx_ltc_attenuation(false, quad_culling_range, in_surface_shading_normal_world_space, quad_vertices_world_space);

        brx_branch if (area_lighting_attenuation > INTERNAL_ATTENUATION_THRESHOLD)
        {
            brx_unroll for (brx_int direction_index = 0; direction_index < (brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT)); ++direction_index)
            {
                brx_float3 outgoing_direction_world_space = in_outgoing_directions_world_space[direction_index];

                brx_branch if (brx_dot(in_surface_shading_normal_world_space, outgoing_direction_world_space) > 0.0)
                {
                    brx_float3 surface_specular_albedo = surface_specular_albedos[direction_index];

                    out_outgoing_radiances[direction_index] += brx_ltc_radiance(false, area_lighting_attenuation, surface_diffuse_albedo, surface_specular_albedo, in_surface_roughness, in_surface_shading_normal_world_space, outgoing_direction_world_space, area_lighting_radiance, in_surface_position_world_space, quad_vertices_world_space);
                }
            }
        }
#elif defined(VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE) && (VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_TOON_SHADING == VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE)
        brx_branch if (in_surface_material_face)
        {
            brx_float area_lighting_attenuation = 1.0;

            brx_float3 N = in_surface_shading_normal_world_space;
            // TODO: ???
            brx_float3 L = brx_normalize(quad_vertices_world_space[0] + quad_vertices_world_space[1] + quad_vertices_world_space[2] + quad_vertices_world_space[3]);

            brx_unroll for (brx_int direction_index = 0; direction_index < (brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT)); ++direction_index)
            {
                brx_float3 outgoing_direction_world_space = in_outgoing_directions_world_space[direction_index];

                brx_float3 V = outgoing_direction_world_space;

                // three base color outgoing radiance
                {
                    brx_float3 area_lighting_direction_model_space = brx_mul(g_inverse_model_transform, brx_float4(L.x, L.y, L.z, 0.0)).xyz;
                    brx_float NdotL = brx_clamp(internal_celluloid_face_shadow_attenuation(in_surface_position_non_deformed_model_space, area_lighting_direction_model_space), -1.0, 1.0);

                    brx_float3 three_base_color_transfer_function = in_surface_diffuse_color * internal_three_base_color_ramp_function(NdotL, area_lighting_attenuation);
                    out_outgoing_radiances[direction_index] += (area_lighting_radiance * three_base_color_transfer_function);
                }
            }
        }
        else
        {
            brx_float area_lighting_attenuation = brx_ltc_attenuation(true, quad_culling_range, in_surface_shading_normal_world_space, quad_vertices_world_space);

            brx_unroll for (brx_int direction_index = 0; direction_index < (brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT)); ++direction_index)
            {
                brx_float3 outgoing_direction_world_space = in_outgoing_directions_world_space[direction_index];

                brx_branch if (brx_dot(in_surface_shading_normal_world_space, outgoing_direction_world_space) > 0.0)
                {
                    brx_float3 surface_specular_albedo = surface_specular_albedos[direction_index];

                    out_outgoing_radiances[direction_index] += brx_ltc_radiance(true, area_lighting_attenuation, surface_diffuse_albedo, surface_specular_albedo, in_surface_roughness, in_surface_shading_normal_world_space, outgoing_direction_world_space, area_lighting_radiance, in_surface_position_world_space, quad_vertices_world_space);
                }
            }
        }
#else
#error Unknown Render Style
#endif
    }

    // Environment Lighting
    brx_float3 fill_lighting_irradiance;
    brx_branch if ((ENVIRONMENT_MAP_LAYOUT_EQUIRECTANGULAR == g_environment_map_layout) || (ENVIRONMENT_MAP_LAYOUT_OCTAHEDRAL == g_environment_map_layout))
    {
        brx_float3 environment_map_sh_coefficients[BRX_SH_COEFFICIENT_COUNT];
        for (brx_int environment_map_sh_coefficient_index = 0; environment_map_sh_coefficient_index < BRX_SH_COEFFICIENT_COUNT; ++environment_map_sh_coefficient_index)
        {
            environment_map_sh_coefficients[environment_map_sh_coefficient_index] = brx_uint_as_float(brx_byte_address_buffer_load3(t_environment_map_sh_coefficients, (3 * (environment_map_sh_coefficient_index << 2))));
        }

#if defined(VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE) && (VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_PHYSICALLY_BASED_RENDERING == VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE)
        brx_float3 shading_normal_environment_map_space = brx_mul(g_world_to_environment_map_transform, brx_float4(in_surface_shading_normal_world_space, 0.0)).xyz;

        brx_float3 environment_lighting_diffuse_radiance = brx_sh_diffuse_radiance(surface_diffuse_albedo, shading_normal_environment_map_space, environment_map_sh_coefficients);

        brx_unroll for (brx_int direction_index = 0; direction_index < (brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT)); ++direction_index)
        {
            brx_float3 outgoing_direction_world_space = in_outgoing_directions_world_space[direction_index];

            brx_branch if (brx_dot(in_surface_shading_normal_world_space, outgoing_direction_world_space) > 0.0)
            {
                // TODO: we do not have ambient occlusion here ???
                // perhaps the screen space ambient occlusion pass is required

                brx_float3 surface_specular_albedo = surface_specular_albedos[direction_index];

                brx_float3 outgoing_direction_environment_map_space = brx_mul(g_world_to_environment_map_transform, brx_float4(outgoing_direction_world_space, 0.0)).xyz;

                brx_float3 environment_lighting_specular_radiance = brx_sh_specular_radiance(surface_specular_albedo, in_surface_roughness, shading_normal_environment_map_space, outgoing_direction_environment_map_space, environment_map_sh_coefficients);

                out_outgoing_radiances[direction_index] += (environment_lighting_diffuse_radiance + environment_lighting_specular_radiance);
            }
        }

        fill_lighting_irradiance = brx_float3(0.0, 0.0, 0.0);
#elif defined(VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE) && (VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_TOON_SHADING == VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE)
        // UTS_MainLight: [defaultLightColor](https://github.com/Unity-Technologies/com.unity.toonshader/blob/master/com.unity.toonshader/Runtime/HDRP/Shaders/DoubleShadeWithFeatherMainLight.hlsl#L69)
        // UTS_MainLightShadingGrademap: [defaultLightColor](https://github.com/Unity-Technologies/com.unity.toonshader/blob/master/com.unity.toonshader/Runtime/HDRP/Shaders/ShadingGrademapMainLight.hlsl#L76)
        brx_float3 environment_lighting_diffuse_normalized_irradiance_zero = environment_map_sh_coefficients[0] * 0.28209479177387814347403972578039;

        // use normal (0.0, 1.0, 0.0) to be consistent with the default light direction "camera_forward + camera_right"
        brx_float3 down_environment_map_space = brx_mul(g_world_to_environment_map_transform, brx_float4(0.0, 1.0, 0.0, 0.0)).xyz;

        brx_float3 environment_lighting_diffuse_normalized_irradiance_down = internal_brx_sh_diffuse_normalized_irradiance(environment_map_sh_coefficients, down_environment_map_space);

        fill_lighting_irradiance = brx_max(environment_lighting_diffuse_normalized_irradiance_zero, environment_lighting_diffuse_normalized_irradiance_down);
#else
#error Unknown Render Style
#endif
    }
    else
    {
        fill_lighting_irradiance = brx_float3(0.0, 0.0, 0.0);
    }

    // Directional Lighting
    {
        brx_float3 N = in_surface_shading_normal_world_space;
        brx_float3 directional_lighting_irradiance;
        brx_float directional_lighting_shadow_attenuation;
        brx_float3 L;
        brx_float NdotL;
#if defined(VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE) && (VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_PHYSICALLY_BASED_RENDERING == VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE)
        brx_branch if (0u != g_directional_lighting_visible)
        {
            L = brx_normalize(-g_directional_lighting_direction);
            NdotL = brx_dot(N, L);
            brx_branch if (NdotL > 0.0)
            {
                directional_lighting_irradiance = g_directional_lighting_irradiance;
                // TODO: Shadow Map
                // directional_lighting_shadow_attenuation = internal_shadow_map(surface_position_world_space);
                directional_lighting_shadow_attenuation = 1.0;
                L = brx_normalize(-g_directional_lighting_direction);
                NdotL = brx_dot(N, L);
            }
            else
            {
                directional_lighting_irradiance = brx_float3(0.0, 0.0, 0.0);
                directional_lighting_shadow_attenuation = 0.0;
                L = brx_float3(0.0, 1.0, 0.0);
                NdotL = 0.0;
            }
        }
        else
        {
            directional_lighting_irradiance = brx_float3(0.0, 0.0, 0.0);
            directional_lighting_shadow_attenuation = 0.0;
            L = brx_float3(0.0, 1.0, 0.0);
            NdotL = 0.0;
        }
#elif defined(VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE) && (VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_TOON_SHADING == VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE)
        // directional_lighting_shadow_attenuation: [-1, 1]
        // NdotL: [-1, 1]
        brx_branch if (0u != g_directional_lighting_visible)
        {
            directional_lighting_irradiance = brx_max(g_directional_lighting_irradiance, fill_lighting_irradiance);
            // TODO: Shadow Map
            // directional_lighting_shadow_attenuation = internal_shadow_map(surface_position_world_space);
            directional_lighting_shadow_attenuation = 1.0;
            L = brx_normalize(-g_directional_lighting_direction);
            NdotL = brx_dot(N, L);
        }
        else
        {
            directional_lighting_irradiance = fill_lighting_irradiance;
            directional_lighting_shadow_attenuation = 1.0;
            // UTS_MainLight: [defaultLightDirection](https://github.com/Unity-Technologies/com.unity.toonshader/blob/master/com.unity.toonshader/Runtime/HDRP/Shaders/DoubleShadeWithFeatherMainLight.hlsl#L68)
            // UTS_MainLightShadingGrademap: [defaultLightDirection](https://github.com/Unity-Technologies/com.unity.toonshader/blob/master/com.unity.toonshader/Runtime/HDRP/Shaders/ShadingGrademapMainLight.hlsl#L74)
            // Rembrandt Lighting
            // zenith 45 degree
            // azimuth 45 degree
            brx_float3 camera_right = brx_mul(g_inverse_view_transform, brx_float4(1.0, 0.0, 0.0, 0.0)).xyz;
            brx_float3 camera_down = brx_mul(g_inverse_view_transform, brx_float4(0.0, -1.0, 0.0, 0.0)).xyz;
            brx_float3 camera_forward = brx_mul(g_inverse_view_transform, brx_float4(0.0, 0.0, -1.0, 0.0)).xyz;
            L = brx_normalize(-(camera_right * 0.5 + camera_down * brx_sqrt(0.5) + camera_forward * 0.5));
            NdotL = brx_dot(N, L);
        }
#else
#error Unknown Render Style
#endif

        brx_branch if (brx_any(brx_greater_than(directional_lighting_irradiance, brx_float3(INTERNAL_IRRADIANCE_THRESHOLD, INTERNAL_IRRADIANCE_THRESHOLD, INTERNAL_IRRADIANCE_THRESHOLD))))
        {
            brx_unroll for (brx_int direction_index = 0; direction_index < (brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_WIDTH_COUNT) * brx_int(BRX_VCT_CLIPMAP_ILLUMINATION_TEXTURE_DIRECTION_HEIGHT_COUNT)); ++direction_index)
            {
                brx_float3 V = in_outgoing_directions_world_space[direction_index];

#if defined(VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE) && (VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_PHYSICALLY_BASED_RENDERING == VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE)
                brx_float NdotV = brx_dot(N, V);
                brx_branch if (NdotV > 0.0)
                {
                    // diffuse outgoing radiance
                    {
                        brx_float3 diffuse_transfer_function = brx_lambert_brdf(in_surface_diffuse_color) * NdotL;
                        out_outgoing_radiances[direction_index] += (directional_lighting_irradiance * diffuse_transfer_function);
                    }

                    // specular outgoing radiance
                    {
                        brx_float square_NdotH;
                        brx_float LdotH;
                        {
#if 0
                            brx_float VdotL = brx_dot(V, L);

                            // Real-Time Rendering Fourth Edition / 9.8 BRDF Models for Surface Reflection / [Hammon 2017]
                            // UE4: [Init](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Shaders/Private/BRDF.ush#L31)
                            // U3D: [GetBSDFAngle](https://github.com/Unity-Technologies/Graphics/blob/v10.8.0/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl#L361)
                            brx_float invLenH = brx_rsqrt(brx_max(INTERNAL_HALF_VECTOR_LENGTH_SQUARE_MINIMUM, 2.0 + 2.0 * VdotL));
                            brx_float NdotH = brx_clamp((NdotL + NdotV) * invLenH, 0.0, 1.0);
                            LdotH = brx_clamp(invLenH * VdotL + invLenH, 0.0, 1.0);

                            square_NdotH = NdotH * NdotH;
#else
                            // [BrdfGGX::eval](https://github.com/selfshadow/ltc_code/blob/master/fit/brdf_ggx.h#L34)
                            // The precision is higher, likely because "normalize" and "sqrt" are omitted
                            brx_float3 not_normalized_H = V + L;
                            brx_float not_normalized_NdotH = brx_dot(N, not_normalized_H);
                            brx_float square_not_normalized_NdotH = not_normalized_NdotH * not_normalized_NdotH;
                            brx_float square_length_not_normalized_H = brx_dot(not_normalized_H, not_normalized_H);

                            brx_branch if ((not_normalized_NdotH > 0.0) && (square_length_not_normalized_H > INTERNAL_HALF_VECTOR_LENGTH_SQUARE_MINIMUM))
                            {
                                square_NdotH = square_not_normalized_NdotH / square_length_not_normalized_H;
                            }
                            else
                            {
                                square_NdotH = 0.0F;
                            }

                            brx_branch if (square_length_not_normalized_H > INTERNAL_HALF_VECTOR_LENGTH_SQUARE_MINIMUM)
                            {
                                LdotH = brx_clamp(brx_dot(L, not_normalized_H * brx_rsqrt(square_length_not_normalized_H)), 0.0, 1.0);
                            }
                            else
                            {
                                LdotH = 0.0F;
                            }
#endif
                        }

                        brx_float VdotH = LdotH;

                        // Real-Time Rendering Fourth Edition / 9.8.1 Normal Distribution Functions: "In the Disney principled shading model, Burley[214] exposes the surface_roughness control to users as g = r2, where r is the user-interface surface_roughness parameter value between 0 and 1."
                        brx_float alpha = in_surface_roughness * in_surface_roughness;

                        brx_float3 f0 = in_surface_specular_color;
                        const brx_float3 f90 = brx_float3(1.0, 1.0, 1.0);

                        brx_float3 specular_transfer_function = brx_trowbridge_reitz_brdf_square_version(alpha, square_NdotH, NdotV, NdotL, f0, f90, VdotH) * NdotL;
                        out_outgoing_radiances[direction_index] += (directional_lighting_irradiance * specular_transfer_function);
                    }
                }
#elif defined(VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE) && (VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE_TOON_SHADING == VOXEL_CONE_TRACING_VOXELIZATION_RENDER_STYLE)
                // three base color outgoing radiance
                {
                    brx_float final_NdotL;
                    brx_branch if (in_surface_material_face)
                    {
                        brx_float3 directional_lighting_direction_model_space = brx_mul(g_inverse_model_transform, brx_float4(L.x, L.y, L.z, 0.0)).xyz;
                        final_NdotL = brx_clamp(internal_celluloid_face_shadow_attenuation(in_surface_position_non_deformed_model_space, directional_lighting_direction_model_space), -1.0, 1.0);
                    }
                    else
                    {
                        final_NdotL = NdotL;
                    }

                    brx_float3 three_base_color_transfer_function = in_surface_diffuse_color * internal_three_base_color_ramp_function(final_NdotL, directional_lighting_shadow_attenuation);
                    out_outgoing_radiances[direction_index] += (directional_lighting_irradiance * three_base_color_transfer_function);
                }

                // rim light outgoing radiance
                {
                    brx_float surface_diffuse_color_maximum = brx_max(brx_max(in_surface_diffuse_color.x, in_surface_diffuse_color.y), in_surface_diffuse_color.z);
                    brx_float3 surface_diffuse_color_tint = brx_clamp(in_surface_diffuse_color / brx_max(1e-7, surface_diffuse_color_maximum), brx_float3(0.0, 0.0, 0.0), brx_float3(1.0, 1.0, 1.0));
                    brx_float3 rim_color = surface_diffuse_color_tint;

                    brx_float NdotV = brx_dot(N, V);

                    brx_float3 rim_transfer_function = rim_color * internal_rim_light_ramp_function(NdotV);
                    out_outgoing_radiances[direction_index] += (directional_lighting_irradiance * rim_transfer_function);
                }
#else
#error Unknown Render Style
#endif
            }
        }
    }
}

brx_uint brx_vct_application_bridge_get_clipmap_mask(in brx_int3 in_mask_texture_coordinates)
{
    return brx_load_3d_uint(u_clipmap_texture_mask, in_mask_texture_coordinates);
}

brx_uint brx_vct_application_bridge_compare_and_swap_clipmap_mask(in brx_int3 in_mask_texture_coordinates, in brx_uint in_old_value, in brx_uint in_new_value)
{
    return brx_texture_3d_uint_interlocked_compare_exchange(u_clipmap_texture_mask, in_mask_texture_coordinates, in_old_value, in_new_value);
}

brx_uint brx_vct_application_bridge_get_clipmap_illumination_opacity_red_green(in brx_int3 in_illumination_texture_coordinates)
{
    return brx_load_3d_uint(u_clipmap_texture_illumination_opacity_r16g16, in_illumination_texture_coordinates);
}

brx_uint brx_vct_application_bridge_compare_and_swap_clipmap_illumination_opacity_red_green(in brx_int3 in_illumination_texture_coordinates, in brx_uint in_old_value, in brx_uint in_new_value)
{
    return brx_texture_3d_uint_interlocked_compare_exchange(u_clipmap_texture_illumination_opacity_r16g16, in_illumination_texture_coordinates, in_old_value, in_new_value);
}

brx_uint brx_vct_application_bridge_get_clipmap_illumination_opacity_blue_alpha(in brx_int3 in_illumination_texture_coordinates)
{
    return brx_load_3d_uint(u_clipmap_texture_illumination_opacity_b16a16, in_illumination_texture_coordinates);
}

brx_uint brx_vct_application_bridge_compare_and_swap_clipmap_illumination_opacity_blue_alpha(in brx_int3 in_illumination_texture_coordinates, in brx_uint in_old_value, in brx_uint in_new_value)
{
    return brx_texture_3d_uint_interlocked_compare_exchange(u_clipmap_texture_illumination_opacity_b16a16, in_illumination_texture_coordinates, in_old_value, in_new_value);
}

#endif
